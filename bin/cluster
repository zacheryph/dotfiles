#!/bin/bash
# shellcheck disable=SC2029
#   SC2029 thinks '--exec-id ssh' is 'ssh': https://github.com/koalaman/shellcheck/wiki/SC2029
CLUSTER_BRIDGE=${CLUSTER_BRIDGE:-kubernetes}
CLUSTER_DNSMASQ=${CLUSTER_DNSMASQ:-kubernetes-dnsmasq}
CLUSTER_NETWORK=${CLUSTER_NETWORK:-172.158.0.0/24}
CLUSTER_NODES=${CLUSTER_NOTES:-"1 2 3"}

CLUSTER_RUNTIME=${CLUSTER_RUNTIME:-docker}
CLUSTER_INIT_FLAGS=${CLUSTER_INIT_FLAGS:-""}

CLUSTER_KUBELET_VCPU=${CLUSTER_KUBELET_VCPU:-2}
CLUSTER_KUBELET_MASTER_MEM=${CLUSTER_KUBELET_MASTER_MEM:-1024}
CLUSTER_KUBELET_NODE_MEM=${CLUSTER_KUBELET_NODE_MEM:-2048}
CLUSTER_KUBELET_DISK=${CLUSTER_KUBELET_DISK:-8G}

NETWORK_PREFIX=$(echo "$CLUSTER_NETWORK" | sed -E "s|([[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+).*|\\1|")
NETWORK_GATEWAY="${NETWORK_PREFIX}.1"
NETWORK_MASTER_ADDR="${NETWORK_PREFIX}.10"
NETWORK_MASTER_MAC="1C:A5:EA:A2:89:30"
NETWORK_RANGE="${NETWORK_PREFIX}.200,${NETWORK_PREFIX}.250"

read -r -d '' USAGE <<EOF
cluster: kubernetes cluster with docker/linuxkit

note: this is very rudamentary. state is not saved.
      will attempt to run stuff twice.

usage:
  cluster qemu     - configure qemu access
  cluster network  - create docker/bridge network
  cluster dnsmasq  - create dnsmasq dhcp server
  cluster init-all - run all initializations
  cluster refresh  - refresh kubernetes images
  cluster master   - create master instance
  cluster setup    - run setup for master instance
  cluster nodes    - start all nodes
  cluster start    - start master and nodes
  cluster stop     - stop the master and all nodes
  cluster init     - sets kubeconfig environment
  cluster exec     - execute a command on the master
  cluster ssh      - ssh into master for the giggles
  cluster clean    - stop and wipe states
  cluster purge    - THE purge.
EOF

usage() {
  echo "$USAGE"
  echo
  exit
}

fatal() {
  echo "!! $*"
  exit
}

init_qemu() {
  sudo chown :kvm /usr/lib/qemu/qemu-bridge-helper
  sudo chmod u+s /usr/lib/qemu/qemu-bridge-helper
  sudo mkdir -p /etc/qemu
  echo "allow $CLUSTER_BRIDGE" | sudo dd status=none of=/etc/qemu/bridge.conf
  sudo chown root:kvm /etc/qemu/bridge.conf
  sudo chmod 0640 /etc/qemu/bridge.conf
}

init_network() {
  docker network create \
    --driver bridge \
    --subnet "$CLUSTER_NETWORK" \
    --gateway "$NETWORK_GATEWAY" \
    --opt 'com.docker.network.bridge.name'="$CLUSTER_BRIDGE" \
    --opt 'com.docker.network.bridge.enable_ip_masquerade'='1' \
    --opt 'com.docker.network.bridge.enable_icc'='1' \
    "$CLUSTER_BRIDGE"
}

init_dnsmasq() {
  docker rm --force "$CLUSTER_DNSMASQ" 2>/dev/null

  docker run \
    --detach \
    --restart always \
    --name "$CLUSTER_DNSMASQ" \
    --cap-add NET_ADMIN \
    --network "$CLUSTER_BRIDGE" \
    --expose 67/udp \
    --dns 8.8.8.8 \
    --dns 8.8.4.4 \
    andyshinn/dnsmasq \
      --bind-interfaces \
      --log-dhcp \
      --dhcp-authoritative \
      --dhcp-range "$NETWORK_RANGE" \
      --dhcp-option "option:router,$NETWORK_GATEWAY" \
      --dhcp-host "${NETWORK_MASTER_MAC},${NETWORK_MASTER_ADDR},master"
}

init_linuxkit() {
  [ -d "${HOME}/src/linuxkit" ] && return
  mkdir -p "${HOME}/src"
  cd "${HOME}/src" || fatal "failed to cd ${HOME}/src"
  git clone https://github.com/linuxkit/linuxkit

  cd "${HOME}/src/linuxkit" && make
}

init_all() {
  init_qemu
  init_network
  init_dnsmasq
  init_linuxkit
}

goto_cluster() {
  cd "${HOME}/.cluster" 2>/dev/null || fatal "cluster not found. run refresh"
}

ensure_setup() {
  [[ -e "${HOME}/.cluster/token" ]] || fatal "token not found. run setup"
  CLUSTER_TOKEN=$(tr -d "\r\n" < "$HOME/.cluster/token")
}

run_master() {
  goto_cluster
  statedir="kube-master-state"
  mkdir -p "$statedir"
  echo -n "${NETWORK_MASTER_MAC}" > "$statedir/mac-addr"
  export KUBE_MASTER_AUTOINIT=1

  ("${HOME}/src/linuxkit/bin/linuxkit" run \
    -networking "bridge,${CLUSTER_BRIDGE}" \
    -cpus "$CLUSTER_KUBELET_VCPU" \
    -mem "$CLUSTER_KUBELET_MASTER_MEM" \
    -state "$statedir" \
    -data '{"kubeadm": {"init": ""}}' \
    -disk "size=$CLUSTER_KUBELET_DISK" \
    kube-master.iso >"$statedir/console.log" 2>&1 &)

  echo "== waiting for master to come up"
  while true ; do
    if timeout 0.5 ping -c1 "$NETWORK_MASTER_ADDR" >/dev/null ; then
      break
    fi
  done
  echo "== master is up and running."
}

ssh_command() {
  ssh \
    -o LogLevel=FATAL \
    -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    -o IdentitiesOnly=yes \
    -t root@"${NETWORK_MASTER_ADDR}" \
    ctr tasks exec --tty --exec-id ssh kubelet "$@"
}

run_exec() {
  ssh \
    -o LogLevel=FATAL \
    -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    -o IdentitiesOnly=yes \
    -t root@"${NETWORK_MASTER_ADDR}" \
    ctr tasks exec --exec-id ssh kubelet "$@" 2>/dev/null
}

run_ssh() {
  ssh_command ash -l
}

run_setup() {
  goto_cluster

  echo "== initializing kubernetes master"
  if ! output=$(ssh_command /usr/bin/kubeadm-init.sh | tee setup.log); then
    echo "failed to run setup:"
    echo "$output"
  fi

  echo "== saving token"
  token=$(echo "$output" | grep "kubeadm join" | sed -E 's/^[[:blank:]]+kubeadm join +//' | sed -E 's/\r$//')
  if [[ -z "$token" ]]; then
    echo "error getting join command. check ~/.cluster/setup.log"
    exit
  fi
  echo "$token" > "${HOME}/.cluster/token"

  echo "== retrieving cluster configuration"
  run_exec cat /etc/kubernetes/admin.conf > "${HOME}/.cluster/config"
}

run_init() {
  echo "# properly load with: eval \"\$(cluster init)\""
  echo "export KUBECONFIG=\"${HOME}/.cluster/config\""
}

run_nodes() {
  goto_cluster
  ensure_setup

  for instance in $CLUSTER_NODES ; do
    echo "== starting node ${instance}"

    statedir="kube-node-${instance}-state"

    if [[ ! -d "$statedir" ]]; then
      mkdir -p "$statedir"
      DATAOPT="{\"kubeadm\": {\"join\": \"${CLUSTER_TOKEN}\"} }"
    fi

    ("${HOME}/src/linuxkit/bin/linuxkit" run \
      -networking "bridge,${CLUSTER_BRIDGE}" \
      -cpus "$CLUSTER_KUBELET_VCPU" \
      -mem "$CLUSTER_KUBELET_NODE_MEM" \
      -state "$statedir" \
      -disk "size=$CLUSTER_KUBELET_DISK" \
      -data "$DATAOPT" \
      kube-node.iso >"$statedir/console.log" 2>&1 &)
  done
}

run_refresh() {
  cd "${HOME}/src/linuxkit/projects/kubernetes" || fatal "linuxkit not found"
  git pull
  # make clean
  make build-vm-images KUBE_RUNTIME="$CLUSTER_RUNTIME" || fatal "failed to build images"
  mkdir -p "${HOME}/.cluster"
  rm -f "${HOME}/.cluster/"kube-{master,node}.iso
  cp kube-{master,node}.iso "${HOME}/.cluster"
}

run_stop() {
  goto_cluster
  for instance in $CLUSTER_NODES ; do
    [[ -e "kube-node-$instance-state/qemu.pid" ]] && kill "$(cat "kube-node-$instance-state/qemu.pid")" 2>/dev/null
  done

  [[ -e "kube-master-state/qemu.pid" ]] && kill "$(cat kube-master-state/qemu.pid)" 2>/dev/null

  rm -f kube-*-state/qemu.pid
}

run_clean() {
  run_stop
  rm -rf "${HOME}/.cluster/kube-*-state"
}

run_purge() {
  run_stop
  rm -rf "${HOME}/.cluster"
  echo "== leaving ${HOME}/src/linuxkit in place."
}


[[ -z "$1" ]] && usage

case "$1" in
  qemu)
    init_qemu
    ;;
  network)
    init_network
    ;;
  dnsmasq)
    init_dnsmasq
    ;;
  linuxkit)
    init_linuxkit
    ;;
  init-all)
    init_all
    ;;
  refresh)
    run_refresh
    ;;
  master)
    run_master
    ;;
  setup)
    run_setup
    ;;
  nodes)
    run_nodes
    ;;
  start)
    run_master
    run_nodes
    ;;
  stop)
    run_stop
    ;;
  init)
    run_init
    ;;
  ssh)
    run_ssh
    ;;
  exec)
    shift
    run_exec "$@"
    ;;
  clean)
    run_clean
    ;;
  purge)
    run_purge
    ;;
  *)
    usage
    ;;
esac
